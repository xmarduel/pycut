<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <title>PYCUT TUTORIAL</title>
  <link href="doc/css/prism.css" rel="stylesheet" />
  <link href="doc/css/pycut.css" rel="stylesheet" />
  <link href="doc/css/simpletree.css" rel="stylesheet" />
  <script type="text/javascript" src="doc/js/prism.js" />
  <script type="text/javascript" src="https://polyfill.io/v3/polyfill.min.js?features=es6">
 </script>
  <script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
 </script>
</head>

<body>
<!-- ----------------------------------------------------------------------------------------------------------->
<!-- ----------------------------------------------------------------------------------------------------------->
<!-- ----------------------------------------------------------------------------------------------------------->
<!-- ----------------------------------------------------------------------------------------------------------->

<div class="sidenav">
<h3 class="title_sidenav">Contents</h3>
<ul class="tree">
  <li><a href="#P-01">Introduction</a> </li>
  <li><a href="#P-02">SVG Documents</a> 
   <ul>
      <li><a href="#P-02-01">SVG ViewBox</a></li>
	  <li><a href="#P-02-02">SVG Shapes and Paths</a>
	    <ul>
          <li><a href="#P-02-02-01">Opened and closed paths</a></li>
	      <li><a href="#P-02-02-02">Text shapes</a></li>
		  <li><a href="#P-02-02-03">Special tags: defs and use</a></li>
		  <li><a href="#P-02-02-04">Transformations</a></li>
        </ul>
	  </li>
    </ul></li>
  <li><a href="#P-03">Basic example</a> 
    <ul>
      <li><a href="#P-03-00">PyCut as GCode simulator</a></li>
	  <li><a href="#P-03-01">Loading a SVG file</a></li>
      <li><a href="#P-03-02">Creating a PyCut Job</a></li>
      <li><a href="#P-03-03">Creating CAM operations</a></li>
      <li><a href="#P-03-04">Generate the GCode</a></li>
    </ul>
  </li>
  <li><a href="#P-04">GUI Components</a> 
    <ul>
      <li><a href="#P-04-01">Svg Settings</a></li>
      <li><a href="#P-04-02">Tool (shared by all Operations)</a></li>
      <li><a href="#P-04-03">Tabs</a></li>
      <li><a href="#P-04-04">Material</a></li>
      <li><a href="#P-04-05">Curve to Line Conversion</a></li>
      <li><a href="#P-04-06">GCode Conversion</a></li>
      <li><a href="#P-04-07">GCode Generation</a></li>
    </ul>
  </li>
  <li><a href="#P-05">CAM Operations</a>
    <ul>
      <li><a href="#P-05-01">Inside</a></li>
      <li><a href="#P-05-02">Outside</a></li>
      <li><a href="#P-05-03">Engrave</a></li>
      <li><a href="#P-05-04">Helix</a></li>
      <li><a href="#P-05-05">Pocket</a></li>
    </ul>	</li>
  <li><a href="#P-06">GCode DressUp</a> </li>
  <li><a href="#APPENDIX-01">Appendix-1: SVG Editors</a></li>
  <li><a href="#APPENDIX-02">Appendix-2: SVG Units and Scale Factor</a></li>
  <li><a href="#APPENDIX-03">Appendix-3: GCODE Viewers</a></li> 
</ul>
<script type="text/javascript">
      var tree = document.querySelectorAll('ul.tree a:not(:last-child)');
      for (var i = 0; i < tree.length; i++) {
        tree[i].addEventListener('click', function (e) {
          var parent = e.target.parentElement;
          var classList = parent.classList;
          if (classList.contains("open")) {
            classList.remove('open');
            var opensubs = parent.querySelectorAll(':scope .open');
            for (var i = 0; i < opensubs.length; i++) {
              opensubs[i].classList.remove('open');
            }
          } else {
            classList.add('open');
          }
          if (classList.contains("open")) {
            //e.preventDefault(); // on open -> jump (default)

          } else {
            e.preventDefault(); // on close
          }
        });
      }</script>
</div>
<!-- ----------------------------------------------------------------------------------------------------------->
<!-- ----------------------------------------------------------------------------------------------------------->
<!-- ----------------------------------------------------------------------------------------------------------->
<!-- ----------------------------------------------------------------------------------------------------------->

<div class="main">

<h1 class="etitle">PyCut Tutorial</h1>

<h2 id="P-01">Introduction</h2>

<p>Welcome to <strong>PyCut</strong>, a clone of <strong>jsCut</strong>, the excellent (at least for beginners) CAM,
web-based programm, that takes as input <strong>SVG</strong> files and generates G-Code. So why this rewrite ?</p>

<p><strong>PyCut</strong> aims to offer all the (minimalistics) features found in jsCut, with some improvements.
Hopefully you will find <strong>PyCut</strong> usefull when learning CNC and producing your first GCode files.</p>

<p>Starting point of <strong>PyCut</strong> are <strong>SVG</strong> files, your designs. Indeed, with
<strong>PyCut</strong>, you do not need to do 3D modelling. For simple milling tasks SVG files (2D) are perfectly OK.
Granted, while it is easy to define circles, rectangles etc. in SVG, SVG paths definitions (for complex shapes) are
unfortunately not so straightforward as one could think, and free software lacks good SVG paths modelling applications.
Infact, writing a SVG file with a text editor is sometimes the best way to go. To generate complex svg paths, other
tools may be used, and the results may be copy/pasted into the hand-written files. <strong>PyCut</strong> recommands
the online tool <strong>SvgPathEditor</strong> for this purpose, see Appendix.</p>

<p>In the following, we point out what has to be taken into consideration when creating "usable" <strong>SVG</strong>
files for <strong>PyCut</strong>. </p>

<h2 id="P-02">SVG Documents</h2>

<h3 id="P-02-01">SVG ViewBox</h3>

<p><strong>PyCut</strong>, in order to work accurately, need the SVG document to define its standard
<strong>width</strong> and <strong>height</strong> attributes with the units "<strong>mm</strong>" or
"<strong>in</strong>". </p>
<pre><code class="language-html">&lt;svg version="1.1" width="&lt;width&gt;mm" height="&lt;height&gt;mm" ... 
 ...
&lt;/svg&gt;</code></pre>

<p>and the <strong>viewbox</strong> definition shall be of the form </p>
<pre><code class="language-html">viewBox="0 0 &lt;width&gt; &lt;height&gt;"</code></pre>

<p>with its width and height corresponding to the SVG attributes <strong>width</strong> and <strong>height</strong>.</p>

<div class="info">
<p><strong>Note:</strong> The specified units are not necessarely the ones specified in the generated GCode(s). There
is is another setting to set the GCode units elsewhere in <strong>PyCut</strong>. Admittingly they should correspond
for the sake of good documentation.</p>
</div>

<p>As an example:</p>
<pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;svg version="1.1" width="200mm" height="100mm" viewBox="0 0 200 100" id="test" 
   xmlns="http://www.w3.org/2000/svg" 
   xmlns:svg="http://www.w3.org/2000/svg"&gt;
  &lt;g id="root"&gt;
    &lt;circle id="circle" cx="30" cy="60" r="20" stroke="black" stroke-width="1" fill="red" /&gt;
    &lt;rect id="rect" x="60" y="40" width="30" height="40" stroke="black" stroke-width="1" fill="green" /&gt;
  &lt;/g&gt;
&lt;/svg&gt;</code></pre>

<h3 id="P-02-02">SVG Shapes and Paths</h3>

<p>The SVG standard is very large, and <strong>PyCut</strong> cannot simply read a svg file, display it, and allow the
user to define cnc operations on the "shapes" defined inside the svg file. Of course, the goal of
<strong>PyCut</strong> is to process as many svg data as possible.</p>

<p>The shapes inside a svg file are the following:</p>
<ul>
  <li><code class="svg_tag">&lt;rect&gt;</code></li>
  <li><code class="svg_tag">&lt;circle&gt;</code></li>
  <li><code class="svg_tag">&lt;ellipse&gt;</code></li>
  <li><code class="svg_tag">&lt;polygon&gt;</code></li>
  <li><code class="svg_tag">&lt;line&gt;</code></li>
  <li><code class="svg_tag">&lt;polyline&gt;</code></li>
</ul>

<p>The powerfull</p>
<ul>
  <li><code class="svg_tag">&lt;path&gt;</code></li>
</ul>

<p>can define in a single path definition many closed or opened (sub)paths.</p>

<div class="warning">
<p><strong>Warning:</strong> Some shapes can completely overlap smaller shapes, depending on the order they are defined
in the SVG, and thus making the smaller shapes invisible in the viewer. In this case, larger shapes should be defined
before the smaller ones, so that the smaller ones are on top of the larger ones.</p>
</div>

<p><strong>PyCut</strong> processes "paths" in order to calculate geometries and cnc tool paths, but thankfully it can
read out of the box all kind of shapes, so there is <strong>no need</strong> to convert your svg files into "paths
only" svgs.</p>

<p>Finally, the user will maybe also want to process the strings written in the svg file:</p>
<ul>
  <li><code class="svg_tag">&lt;text&gt;</code></li>
</ul>

<div class="warning">
<p><strong>Warning:</strong> Strings are not (yet) imported directly. They have first to be converted to paths. </p>
</div>

<p>In the following, we will employ the term "shapes" for svg shapes as well as for svg paths.</p>

<p>In order to reference the shapes, the shapes must have their own <strong>"id"</strong>, hopefully unique inside the
svg document. The user, having edited the svg file "per hand" or not, should not forget to check and give the shapes he
wishes to process unique ids.</p>

<div class="info">
<p><strong>Note:</strong> PyCut will only display shapes in its viewer which have an id.</p>
</div>

<div class="info">
<p><strong>Note:</strong> These ids play the role of the shapes name, so a good practice is to give them meaningfull
values (names).</p>
</div>

<h4 id="P-02-02-01">Opened and closed paths</h4>

<p>A path can be closed or not. This is not a matter if the path's first point is equal to its last point. A closed
path or subpath contains the annotation <strong>"Z"</strong> or <strong>"z"</strong> at its end. Even if the first
point of the path is equal to its last point, the path is only considered as closed with the ending
<strong>"Z"</strong> or <strong>"z"</strong>.</p>

<div class="warning">
<p><strong>Warning:</strong> PyCut strongly relies on the <strong>[Zz]</strong> annotation to decide if the path is
closed or not. When not closed, "Pocket" operations will not be allowed for this opened path.</p>
</div>

<p><strong>PyCut</strong> imports closed paths as shapely "MultiPolygon", while opened paths are imported as
"MultiLineString", but here the sake of simplicity, we will only refer them as "Polygon" or "LineString".</p>

<p><strong>PyCut</strong> will import the other shapes either as "<span style="color:#0000ff">Polygon</span>" (i.e.
<strong>closed items</strong>) or as "<span style="color:#0000ff">LineString</span>" (i.e. <strong>opened
items</strong>). Of course, svg <code class="svg_tag">&lt;rect&gt;</code>, <code class="svg_tag">&lt;circle&gt;</code>,
<code class="svg_tag">&lt;ellipse&gt;</code> and <code class="svg_tag">&lt;polygon&gt;</code> are closed items, while
<code class="svg_tag">&lt;line&gt;</code> and <code class="svg_tag">&lt;polyline&gt;</code> are opened items. When
importing a <span style="color:#0000ff">&lt;path&gt;</span>, things are more complicated, as a path can be composed of
many subpaths (starting with [<strong>Mm</strong>]) and every subpath can be closed or not (ending with
[<strong>Zz</strong>]). <strong>PyCut</strong> will try to import these paths definitions right, and in case of closed
paths will also try to import them as shapely polygons "<strong>with holes</strong>" even if this concept does not
exist in SVG. Moreover <strong>PyCut</strong> will try to import a svg path as a valid (shapely) <span
style="color:#0000ff">MultiPolygon </span> in the shapely sense, or as a list of valid MultiPolygons if one single
valid MultiPolygon is not possible. For example, the letters "i" or "j" are defined with a single svg path, defining
two separates polygons, and it makes sense to consider these paths as a single shapely MultiPolygon entity. The letter
"a" is a polygon with one hole, the letter "g" is a polygon with two holes (for some fonts). In the freetype
vocabulary, "a" is formed by 2 "contours", "g" by three "contours".</p>

<h4 id="P-02-02-02">Text shapes</h4>

<p><strong>PyCut</strong> cannot process yet <code class="svg_tag">&lt;text&gt;</code> items directly. Fortunately,
<code class="svg_tag">&lt;text&gt;</code> items can be converted into<code class="svg_tag">&lt;path&gt;</code> items,
sonce they will be ignored by <strong>PyCut</strong>. <strong>PyCut</strong> also comes with the utiilty
<strong>svgtext2svgpath.py</strong> which will also convert your <code class="svg_tag">&lt;text&gt;</code> items. How
to use it? just call the <strong>svgtext2svgpath.py</strong> program which outputs in a new svg the <code
class="svg_tag">&lt;text&gt;</code> items as <code class="svg_tag">&lt;path&gt;</code> items. Copy/paste the result of
a <code class="svg_tag">&lt;text&gt;</code> conversion into your own svg. A successfull conversion will only occurs if
the <code class="svg_tag">&lt;text&gt;</code> item is simple enough: the text "value" should not be splitted into
several <code class="svg_tag">&lt;tspan&gt;</code> items with different fonts. No <code
class="svg_tag">&lt;tspan&gt;</code> tag at all is also possible (and simpler). <strong><span style="color:#8000ff">IN
PROGRESS</span></strong>.</p>

<p>This utility is found in the source code inside the folder "<strong>utilities/svgtext2svgpath.</strong>" </p>

<p>All in all, if <strong>PyCut</strong> were to display text strings at the wrong positions (after having transformed
them into paths), the user can always export the svg from <strong>Inkscape</strong> (and write <strong>PyCut</strong> a
ticket).</p>

<h4 id="P-02-02-03">Special tags: defs and use</h4>

<p><strong>PyCut</strong> cannot import directly the very handy SVG <strong>&lt;defs&gt;</strong> and
<strong>&lt;use&gt;</strong> feature. The utility <strong>svgresolver.py</strong> delivered with <strong>PyCut</strong>
will have to be used. The utility <strong>svgresolver.py</strong> takes as input the SVG file containing
<code>&lt;defs&gt;</code> and <code>&lt;use&gt;</code> tags and outputs a new SVG where all
<code>&lt;defs&gt;/&lt;use&gt;</code> have been resolved, i.e. turned into real objects.</p>

<p>This utility is found in the source code inside the folder "<strong>utilities/svgresolver.</strong>" </p>

<p>One drawback is that the user has then to manage 2 SVG files: the first one with <strong>&lt;defs&gt;</strong> and
<strong>&lt;use&gt;</strong>, and a second one, the "resolved" one which is the input file for <strong>PyCut</strong>.
</p>

<h4 id="P-02-02-04">Transformations</h4>

<div class="info">
<p><strong>Info:</strong>Transformations can be defined on every shapes or groups, and are often used in combinaison
with the <strong>&lt;defs&gt;</strong> and <strong>&lt;use&gt;</strong> tags.</p>
</div>

<p><strong>PyCut</strong> cannot handle "out of the box" svg datas where shapes are defined with "transform" operations
(translate, rotate etc.).</p>

<p>Nevertheless, it is also possible to "resolve" the shapes transformations with the previously mentioned utility
<strong>svgresolver.py</strong>. This utility also processes all transformations found in the svg file, while keeping
the<strong>"id"</strong>s right. It works best in combinaison of the <code><span
style="color:#0000ff">&lt;use&gt;</span></code> tag, as a single item defined in the <code><span
style="color:#0000ff">&lt;defs&gt;</span></code> section can then be re-used at many locations. Obviously, not
everything is possible: for example, transforming a <code><span style="color:#0000ff">&lt;rect&gt;</span></code>
element with a rotate transformation does not result in a <code><span style="color:#0000ff">&lt;rect&gt;</span></code>
(but a <code><span style="color:#0000ff">&lt;polygon&gt;</span></code>) and <strong>svgresolver.py</strong> cannot
handle this.</p>

<p><strong><span style="color:#8000ff">IN PROGRESS</span></strong>: this utility should be integrated into
<strong>PyCut</strong> so that the user can spare this step.</p>
<!-- ----------------------------------------------------------------------------------------------------------->
<!-- ----------------------------------------------------------------------------------------------------------->

<h2 id="P-03">Basic example</h2>

<h3>Opening the PyCut application</h3>

<p>type in the console:</p>

<p><code>&gt; python pycut.py -h</code></p>

<p><code>&gt; python pycut.py --proj=&lt;projectfile&gt;</code></p>

<p><code>&gt; python pycut.py --gcode=&lt;gcodefile&gt;</code></p>

<p>Without argument, pycut opens without loading any SVG file. With the <code>--proj</code> argument, a previously
saved project is opened.</p>

<h3 id="P-03-00">PyCut as GCode simulator</h3>

<p><strong>PyCut</strong> can also be used as a GCode viewer or simulator. GCode files can be loaded with the
argument</p>

<p><code>&gt; python pycut.py --gcode=&lt;gcodefile&gt;</code></p>

<p>Hopefully PyCut can parse it (roughly: what <strong>Candle</strong> can parse - <strong>PyCut</strong> uses a
similar parser). The toolpaths can then be viewed in the GCode viewer (toolpaths simulation) and GCode simulator
(material removing simulation). For the GCode simulator, the tool diameter is needed for an accurate simulation. PyCut
saves its generated gcode files with a comment line of the form</p>
<pre><code class="language-gcode">; Diameter   &lt;value&gt;</code></pre>

<p>that is parsed to retrieve the right tool diameter. Inserting such a line in the external GCode allows
<strong>PyCut</strong> to properly simulate the GCode.</p>

<h3 id="P-03-01">Loading a SVG file</h3>

<p>So for the very first time, start <strong>PyCut</strong> without specifying any project.</p>

<p>Import your svg into <strong>PyCut</strong>. It is achieved through the menubar command <strong>SVG | Load
SVG</strong>. The SVG content should be displayed in the central area. </p>

<h3 id="P-03-02">Creating a PyCut Project</h3>

<p>Then create a new "project" : this is a file that stores uponside the svg file all the CAM operations that the user
has created or will create, together with all others settings relevant when generating GCode. It can be created, saved
and loaded again and modified - quite practical.</p>

<h3 id="P-03-03">Creating CAM operations</h3>

<p>Once an empty project is created and a svg file loaded, it is time to create some CAM operations: select 1 or more
items in SVG window (they should turn beige) and click the button "Create Operation": a new operation in the operation
table should appear.</p>

<p>Define the properties of the operation: the main one is the CAM operation type: </p>
<ul>
  <li><strong>Pocket</strong></li>
  <li><strong>Engrave</strong></li>
  <li><strong>Inside</strong></li>
  <li><strong>Outside</strong></li>
</ul>

<p>There are also the</p>
<ul>
  <li><strong>Drill</strong></li>
  <li><strong>Peck</strong></li>
</ul>

<p>operations, for the <span style="color:#0000ff">&lt;circle&gt;</span> shapes whose diameter is smaller or equal to
the tool diameter, and the </p>
<ul>
  <li><strong>Helix</strong></li>
</ul>

<p>operation for <span style="color:#0000ff">&lt;circle&gt;</span> of any size. </p>

<p>The others options will be discussed later. Default values at this point should be Ok.</p>

<h3 id="P-03-04">Generate the GCode</h3>

<p>Select (enable) one or more CAM operations in the operations table: the "geometry" of the operation(s) should turn
black in the SVG viewer: this is (are) the region(s) of the material that wil be affected when cutting the material.</p>

<p>Then finish creating the G-Code by pressing the button "Generate GCode" above the operation table: the tool path(s)
should appear(s) in green in the black regions.</p>

<p>The produced G-Code can be inspected in the "G Code viewer" and the "G Code Simulator" display areas.</p>

<p>You just have to save the G-Code and you're done. The G-Code file should be named as the CAM operation name, or, in
case of multiple operations enabled, as the project name, with ending suffix "nc".</p>
<!-- ----------------------------------------------------------------------------------------------------------->
<!-- ----------------------------------------------------------------------------------------------------------->

<h2 id="P-04">GUI Components</h2>

<h3 id="P-04-01">Svg Settings</h3>

<div>
<img src="doc/pycut_svgsettings.png" width="310px"> </div>

<h4>Title</h4>

<p>This will display the SVG title if set</p>

<h4>Width</h4>

<h4>Height</h4>

<p></p>

<h3 id="P-04-02">Tool</h3>

<div>
<img src="doc/pycut_tool.png" width="310"> </div>

<h3 id="P-04-03">Tabs</h3>

<p>It's easy to define tabs with <strong>PyCut</strong>: just click the button "Create Tab" and a red circle is created
in the svg viewer, of radius 5 and position (10,10). The user can drag 'n drop it from the svg viewer, or set its
size/postion in the tab table. Yes tabs, for simplicity, are circle. To be effective, the tabs have to be enabled and
of course placed somewhere on the generated toolpaths. The height of the tabs is shared by all tabs. <strong>They are
ignored for Pocket operations</strong>.</p>

<div>
<img src="doc/pycut_tabs.png" width="310"> </div>

<p></p>

<p>You can check the Gcode generation in the viewer/simulator if everythings is Ok. </p>

<h3 id="P-04-04">Material</h3>

<p>The Operations "Cut Depth" should not be larger than the material thickness. </p>

<div>
<img src="doc/pycut_material.png" width="310"> </div>

<p></p>

<div class="warning">
<p><strong>Warning</strong>: The clearance is written in the produced g-code. Thus the user should be sure it does not
exceed the physical possibilities of the machine when travelling in the z-axis, especially for small machines like the
1419 or 1310.</p>
</div>

<div class="warning">
<p><strong>Warning</strong>: The thickness as none impact on the produced GCode. It is only there to remaind that every
CAM operation should not exceed this value (no check performed). The depth cut of any operation should not exceed the
material real thickness, or only exceeding it with a minimal value, only to be sure to cut through, and knowing there
is a spoilboard that has an acceptable thickness.</p>
</div>

<h3 id="P-04-05">Curve to Line Conversion</h3>

<p>If your design contain curves (svg "arcs" or "bezier" curves), they have to be discretized in small segments.</p>

<div>
<img src="doc/pycut_curve_to_line_conversion.png" width="300"></div>

<p>The 2 following parameters allow to specified how fine the curve discretization will be:</p>
<ul>
  <li>Minimun number of segments</li>
  <li>Minimum Segments length</li>
</ul>

<h3 id="P-04-06">GCode Conversion</h3>

<p>The starting location of a milling operation is given by the initial location in the GCode. Per default, PyCut gives
as starting point the (0,0) coordinates of the SVG file, which is located at the top-left of the material. The SVG
conventions are opposite to GCode convention considering the Y direction.</p>

<p>So the GCode generation will have to invert the direction of the Y axis coordinates. But still the reference is the
top-left postion.</p>

<p>It is possible to change the reference location of the generated GCode</p>
<ul>
  <li>Zero top left of the material</li>
  <li>Zero lower left (bottom) of the material</li>
  <li>Zero lower left (Op) i.e bottom left of the area defined by the Gcode</li>
  <li>Zero Center (Op) i.e center of the area defined by the Gcode</li>
</ul>

<div>
<img src="doc/pycut_gcode_conversion.png" width="310"> </div>

<p>Note that these 4 buttons act as radio buttons.</p>

<div class="info">
<p><strong>Note</strong>: In case of lower left (bottom) of the material, the Y size of the material is extracted form
the svg file: the svg "height" attribute.</p>
</div>

<p>These four basic options set the X-Offset and Y-Offset of the GCode calculation. After a GCode generation, it is
still possible to modify the X-Offset and Y-Offset to fit at best how to user wants to have the origin be located with
the help of the 2 spin boxes. Infact, modifying "per hand" the X or Y offsets recalculate the GCode, so this is a
costly operation.</p>

<p>The checkbox "Use Offset" is used, as example, as the following: first, the checkbox is unset. The user selects only
one CAM operation, with for example the option <strong>Zero Center (Op)</strong>. The X and Y offsets are thus
automatically evaluated. Then the user checks "on" the <b>"Use Offset"</b> checkbox, so that these offsets are frozen
and become the references for the further CAM operations and their produced gcodes. </p>

<div class="warning">
<p><strong>Info</strong>: The two SpinBox entries are "debounced" when entering the values from the keyboard, as each
change of value calls the GCode generator, which is a costly operation. So only by typing "Enter", the GCode generator
is then called. Utilizing the spin boxes arrows is not debounced, so at every step the GCode is recalculated.</p>
</div>

<p>Lets give an example: in a SVG file, two circles are defined, one has to be pocketed with a depth of 10mm, the other
with 5 mm. So two operations are needed. Imagine the center of the first circle is at (10,15) and the center of the
second circle is at (20,25). If boths operations are relative from the "Zero top-Left material" reference, no problem.
You have to position your bit exactly at the "top-left" of your material in order to mill the first hole at exactly
(10,15) from this initial position. </p>

<p>But imagine you want the reference to be the center of the first circle. After having generated the GCode for the
first circle, click on "Zero Center (Op)" and observe and carefully note what are the resulting X an Y offsets (it will
be (-10, 15)). Now select the second operation and generate the GCode. The offsets will certainly chande, but then type
in the offsets the memorized X and Y offsets. The GCode will be reevaluated with the offsets (-10,15) and thus the
GCode 0,0 position will be the center of the first circle.</p>

<p>But why would you want to have as reference of the GCode the center of the first circle ? Well when milling the two
holes in your workpiece maybe you may want to position the bit at a given position on the workpiece and from this
location mill the second holes, the first hole beeing milled exactly when you have positioned your bit. Because what
was important was the relative position of the two holes, while the absolute position of the first hole was to be
determinated by yourself on the workpiece.</p>

<p>An other use case is when 2 oparations have to be performed with a different tool diameter.</p>

<div class="warning">
<p><strong>Info</strong>: The option <strong>"Zero Center (Op)"</strong> is particularely usefull when the user wants
to run 2 differents G-Code files produced from 2 different CAM operations. A use case is when these 2 CAM operations
have 2 different tool diameters. By ensuring that the center of the operations are the same, at the end of the first
operation (first GCode file), the user can change the tool in the machine and load/start the second G-Code file. This
occurs when some holes have to be drilled in the first operation and a contour or pocket operation has to be performed
in the second operation with a much larger tool. Of course the two operations must have the same center. If not the
case, the XOffset and YOffset can be set to ensure that the centers are coincidents.</p>
</div>

<p></p>

<p>And further:</p>
<ul>
  <li>Flip X/Y </li>
</ul>

<p>In the generated G Code, X and Y are switched.This can be helpfull, for example in the case your
<strong>CNC</strong> is the "<strong>1419</strong>" model (mine!) which is not as large as deep. So this option allows
to carve something like 16x10 cm without rotating all items in the source svg. </p>

<p></p>

<h3 id="P-04-07">GCode Generation</h3>

<p>Some useful options can be set up:</p>
<ul>
  <li>Return at initial location at end of the Job</li>
  <li>Spindle Start/Stop (<strong>M3</strong>/<strong>M5</strong> codes)</li>
  <li><strong>M2</strong> code</li>
</ul>

<p>Note that the generated GCode is meant to be used for a GRBL control board, so only "lines" are generated, no "arcs"
or other fancy GCode directives.</p>

<div>
<img src="doc/pycut_gcode_generation.png" width="310"></div>
<!-- ----------------------------------------------------------------------------------------------------------->
<!-- ----------------------------------------------------------------------------------------------------------->

<p></p>

<h3>Create Operations</h3>

<p>This is where the user defined its cam operations, thus this is where the action takes place.</p>

<div>
<img src="doc/pycut_ops.png" width="1170"> </div>

<p>First one or more item(s) have to be selected in the svgviewer, click on "Create Operation" and a default operation
is created. When more than one item has been selected, the user can perform logical operations on this set of item </p>
<ul>
  <li>diff</li>
  <li>intersect</li>
  <li>union</li>
  <li>xor</li>
</ul>

<p>When "enabling" this op, the resulting geometry will be displayed ion the svgviewer</p>

<div class="info">
<p><strong>Note:</strong> The geometry is highlighted in red. The highlight color can be setup in the settings dialog,
or from the menu bar (these 3 strange colored buttons). It is useful to choose a color different from the color of your
shapes.</p>
</div>

<p>Then the cam operation can be chosen</p>
<ul>
  <li>pocket - only for closed shapes</li>
  <li>inside</li>
  <li>outside</li>
  <li>engrave</li>
  <li>drill <strong><span style="color:#0000ff">- ONLY</span> <span style="color:#0000ff">for circle
    shapes</span></strong></li>
  <li>peck <strong><span style="color:#0000ff">- ONLY for circle shapes</span></strong></li>
  <li>helix <strong style="color:#0000ff">- <span style="color:#8000ff"><span style="color:#000000"></span></span>ONLY
    for circle/ellipse/rectangle/polygon/closed path shapes</strong></li>
</ul>

<p>For opened paths, the pocket/drill/peck operations are not available.</p>

<p><strong><span style="color:#8000ff">NEW</span></strong>: for <strong>circles</strong>, "<span
style="color:#8000ff"><strong>drill</strong></span>" and "<strong><span style="color:#8000ff">peck</span></strong>"
operations are available. Infact, for a pocket operation with a circle of diameter smaller than the cutter diameter, no
tool path would be generated.<strong>In case of the</strong> <strong>circle diameter is smaller or equal than the
cutter diameter</strong>, in order to have toolpath, "<strong><span style="color:#8000ff">drill</span></strong>" or
"<strong><span style="color:#8000ff">peck</span></strong>" is the way to go. </p>

<p><strong style="color:#8000ff">NEW</strong>: for
<strong>circles</strong>/<strong>ellipses</strong>/<strong>rectangles</strong>/<strong>polygons and more generatly
closed paths</strong>, the "<strong style="color:#8000ff">helix</strong>" operation is available. This cut "smoothly"
in the center of the shape an hole or a donut, depending on the radius of the helix and the cutter diameter. The helix
has always the tickness of the cutter diameter.</p>

<p>In order to generate G code, enable one or many operations and click on "Generate G code". <strong>PyCut</strong>
will try to do its best... The resulting G code is displayed in the G code viewer and G code simulator.</p>

<p>Finally, clicking on "Save G code" will produce a valid G code file. <strong>Candle</strong> can be used to send the
G code to your machine. Have fun...</p>

<p></p>
<!-- ----------------------------------------------------------------------------------------------------------->
<!-- ----------------------------------------------------------------------------------------------------------->

<h2 id="P-05">CAM Operations</h2>

<h3 id="P-05-01">Inside</h3>

<h3 id="P-05-02">Outside</h3>

<p>While the name speaks for itself, be aware that it is possible to make a cut from a virtual "stock" by setting the
"width" of the operation. This does not however allow to cut any kind of stock as the "width" is constant all over the
coutour we wish to cut from the ouside. Nevertheless, knowing the exact dimensions of the material you are cutting, it
is possible to define fake shapes in order to cut them as a virtual stocks.</p>

<h3 id="P-05-03">Engrave</h3>

<p>This cuts exactly on the shapes borders. Be aware that the cutter has a diameter!.</p>

<h3 id="P-05-04">Helix</h3>

<p>The helix's center will be the <strong>center of the (closed) shape</strong>. For a circle, this is obviously the
center of the circle shape. Considering the case where the center of the helix is [0,0], <strong>on which "orbit" will
move the cutter</strong>? Well in case of an Helix operation, the "<strong>width</strong>" operation corresponds to the
helix outer radius. This means that the <strong>radius</strong> of the orbit, the circle on which the cutter center
travels, is <code>width - cutter_radius</code>. So the width has to be larger than the cutter radius, sonce the helix
will be infact a drill operation. A value larger than the cutter diameter generates a ring (with an inner hole), and
the helix is then simular to an "Inside" or "Outside"operation for an imaginary circle shape, however with a "smoother"
cut. </p>

<p>The helix pitch (revolution depth) is the most important parameter. Theoretically, the Helix operation could perform
threads cutting by generating first an hole, then an helix "inside the hole" where the outer radius of the helix would
be smaller than the hole radius, and utilizing a dedicated cutter.</p>

<h3 id="P-05-05">Pockets</h3>

<p>The standard pocket algorithm is the so-called "<strong>contour</strong>" algorithm. Starting from the outside
border, offset curves are generated one after the other until the whole pocket "space" is processed. At the end,
ordering of the offsets is reversed, thus starting from the middle of the pocket.</p>

<p>There are others algorithms, for example the "<strong>spirale</strong>" algorithm. Here we start fom the center of
the pocket and go towards the outside in spirales, hence the name. It is easy to calculate the toolpaths for
<strong>circles</strong> and <strong>ellipses</strong>. For the other shapes, <strong>PyCut</strong> utilizes the
external (free) library <strong style="color:#8000ff">HSM_nibblers</strong> which produces very nice
toolpaths<strong>.</strong></p>

<p><strong>PyCut</strong> will try to implement this <strong>pocket</strong> algorithm in two steps: first an
"<strong>Helix</strong>" operation, then a "<strong>Pocket</strong>" operation.</p>

<p></p>

<p><strong style="color:#8000ff">Trick</strong>: to "activate" the spirale algorithm, just name the pocket operation
with a "<strong>sp_</strong>" prefix! </p>

<p><strong style="color:#8000ff">Trick</strong>: to "activate" the HSM_nibbler algorithm, just name the pocket
operation with a "<strong>hsm_</strong>" prefix! </p>

<div class="info">
<p><strong>Note:</strong> To enable the Spirale pocket toolpaths, prefix the pocket operation with "sp_"</p>
</div>

<div class="info">
<p><strong>Note:</strong> To enable the HSM pocket toolpaths, prefix the pocket operation with "hsm_"</p>
</div>

<p>The helix will be cut in the "center" of the shape (the shapely polygon "centroid)", and we pass this location to
the HSM nibbler, thus ensuring a good start of the pocket "hsm_nibbler" operation.</p>

<p>The spirales will be for <strong>circles, ellipses</strong> shapes only -something admittingly rather restrictive-
because these cases are more or less trivial. There is then no "isles" that neccessarely occur in the corners of the
pocket for non-trivial geometries. But the HSM_nibblers toopaths are there for the others shapes.</p>

<div class="info">
<p><strong>Note:</strong> Having succesfully created an helix (hole) into the center of a basic shape
(<strong>circle</strong>, <strong>ellipse</strong>, <strong>rectangle</strong>, <strong>polygon</strong> or
<strong>closed path</strong>), then the "standard" pocket algorithm can be used with a <strong>very large
overlap</strong> (value close to 1) and <strong>a larger pass depth</strong> (rather than a standard overlap and a tiny
pass depth that is used for standard pockets)</p>
</div>

<h4>Pocket/Spirale</h4>

<p>With a Pocket/Spirale operation, the cutter will plunge automatically with a <strong>depth</strong> equal to the
specified standard <strong>pass depth</strong>. Hopefully a hole has previously been cut at this place... At best, an
Helix operation precedes a Spirale operation. The spirale will mainly cut into the material "sideways". It seems it is
a better way to mill pockets, as the bit is then used mainly from the side, preserving its drilling bottom side if the
<strong>pass depth</strong> is equal to the <strong>full cut depth</strong>.</p>

<p>For a Pocket/Spirale operation to work best, as the pass depth is large, a very big overlap is required (example:
0.975). This way, the spirale only "attacks" the material on a rather limited side surface, thus preserving the bit and
allowing greather depth passes. If you wish for example that at each spirale arm 1mm is milled, then the overlap has to
be chosen accordingly. Denoting A the size of the material beeing cut at each spirale arm : A = cutter_radius *
(1-overlap) =&gt; overlap = 1 - A / cutter_radius.</p>

<p>So a combined "Helix+Pocket/Spirale" operation is somehow similar to the normal "pocket" operation when a very large
pass depth and an overlap near to 1.0 are chosen. Nevertheless, with the "contour" algorithm , the cutter would plunge
into the material without helix (even if a ramp is still possible) for a large pass depth at the given plunge rate,
which would be quite dangerous even if the plunge rate would be small. </p>

<p>Note that for an Helix or Pocket/Spirale operation, cam paths are calculated "per hand" without the help of the
shapely library and its "offset curve" functionality. But the <strong>Spirale</strong> can only be used when
considering <strong>circle/ellipse</strong> or <strong>rectangle</strong> shapes.</p>

<p>The <strong>ellipse and rectangle</strong> cases are derived from the circle case by mapping the coordinated of the
path points from a circle to an ellipse/rectangle. The middle of these shaped has to be evaluated first, and the
mapping between circle and ellipses/rectangles as well.</p>

<p></p>

<h2 id="P-06">GCode DressUp (TODO)</h2>

<h3>DogBones</h3>

<div class="warning">
<p><strong>Warning:</strong> I am a CAM beginner, so for sure my solution is for sure sub-optimal.</p>
</div>

<p>When milling a pocket or a contour, the cutter is not able to mill into convex angles perfectly (yes the cutter is
round). </p>
<svg width="400mm" height="80mm" viewBox="0 0 400 80" version="1.1">
  <g id="layer1">
    <polyline points="10,10 70,10 113,53" stroke-width="0.5" fill="none" stroke="black"/>
    <polyline points="10,20 66.2,20 106.2,60" fill="none" stroke="blue" stroke-linejoin="round" stroke-width="20px"
              stroke-opacity="0.2"/>
    <polyline points="10,20 66.2,20 106.2,60" fill="none" stroke="black" stroke-linejoin="round" stroke-width="0.2"
              stroke-opacity="0.8"/>
    <polyline points="10,30 80,30" fill="none" stroke="black" stroke-linejoin="round" stroke-width="0.2"
              stroke-opacity="0.8" stroke-dasharray="0 1 0"/>
    <!--
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <polyline points="70,10 66.2,20" fill="none" stroke="black" stroke-linejoin="round" stroke-width="0.2" stroke-opacity="0.8" stroke-dasharray="0 1 0"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        -->
    <circle cx="66.2" cy="20" r="10" fill="red" stroke-width="0.2" fill-opacity="0.2" stroke-opacity="0.1"/>
  </g>
  <g id="layer1" transform="translate(120 0)">
    <polyline points="10,10 70,10 100,53" stroke-width="0.5" fill="none" stroke="black"/>
    <polyline points="10,20 65.0,20 93.2,60" fill="none" stroke="blue" stroke-linejoin="round" stroke-width="20px"
              stroke-opacity="0.2"/>
    <polyline points="10,20 65.0,20 93.2,60" fill="none" stroke="black" stroke-linejoin="round" stroke-width="0.2"
              stroke-opacity="0.8"/>
    <polyline points="10,30 80,30" fill="none" stroke="black" stroke-linejoin="round" stroke-width="0.2"
              stroke-opacity="0.8" stroke-dasharray="0 1 0"/>
    <!--
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <polyline points="70,10 66.2,20" fill="none" stroke="black" stroke-linejoin="round" stroke-width="0.2" stroke-opacity="0.8" stroke-dasharray="0 1 0"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      -->
    <circle cx="65.2" cy="20" r="10" fill="red" stroke-width="0.2" fill-opacity="0.2" stroke-opacity="0.1"/>
  </g>
</svg>
<svg width="400mm" height="80mm" viewBox="0 0 400 80" version="1.1">
  <g id="layer1" transform="translate(120 0)">
    <polyline points="10,70 10,10 100,10 100,70" stroke-width="0.5" fill="none" stroke="black"/>
    <polyline points="20,70 20,20 90,20 90,70" fill="none" stroke="blue" stroke-linejoin="round" stroke-width="20px"
              stroke-opacity="0.2"/>
    <polyline points="20,70 20,20 90,20 90,70" fill="none" stroke="black" stroke-linejoin="round" stroke-width="0.2"
              stroke-opacity="0.8"/>
    <circle cx="20" cy="20" r="10px" fill="red" stroke-width="0.2" fill-opacity="0.2" stroke-opacity="0.1"/>
    <circle cx="90" cy="20" r="10px" fill="red" stroke-width="0.2" fill-opacity="0.2" stroke-opacity="0.1"/>
  </g>
  <g id="layer1">
    <polyline points="10,10 110,10 60,60" stroke-width="0.5" fill="none" stroke="black"/>
    <polyline points="10,20  86,20 46,60" fill="none" stroke="blue" stroke-linejoin="round" stroke-width="20px"
              stroke-opacity="0.2"/>
    <polyline points="10,20  86,20 46,60" fill="none" stroke="black" stroke-linejoin="round" stroke-width="0.2"
              stroke-opacity="0.8"/>
    <circle cx="86" cy="20" r="10" fill="red" stroke-width="0.2" fill-opacity="0.2" stroke-opacity="0.1"/>
  </g>
</svg>

<p>Note that the amount of material not removed by the cutter depends on the angle of the corner and the radius of the
cutter.</p>

<div class="info">
<p><strong>Note:</strong> For concave angles, the generated toolpaths around such corners are smooth and do not need
any fixups.</p>
</div>

<p>Fixing the GCode "per hand" is absolutely no solution, so an automatic handling has to be perfomed.</p>

<div class="warning">
<p><strong>Warning:</strong> Having had a look at (the doc of) some other tools (<strong>BlenderCam</strong>,
<strong>Fusion360</strong>), I have noticed that these tools, in order to perform dogbones correction, "actualize" the
geometry, or rather said the geometry contour so that this contour get bones. After that, the "inside" or "pocket"
operations are performed "as usual". I will try to take a different approach : only the generated GCode will be "fixed"
when encountering "angles". </p>
</div>

<div class="warning">
<p><strong>Warning:</strong> A drawback of this approach is that the user has 0 influence on the dogbones generation.
On the other, he does not have to specify them at all </p>
</div>

<h3>A first try</h3>

<p>Let's get a taste how dogbone handling look like. Here we suppose the cutter radius is <strong>3mm</strong>. We wish
to mill an inner square hole, so the "convex angle" corner problem occurs. We have 2 (or more!) strategies to allow a
square to fit in the milled hole. Strategy "1" is shown on the left, strategy "2" on the right: the extra tool path is
displayed with the cutter at the end of the extra tool path (as well as the standard cutter position at the toolpath
corner).</p>
<svg width="200mm" height="100mm" viewBox="0 0 200 100" version="1.1">
  <style>
    .small {font: italic 3px sans-serif;}</style>
  <g id="layer">
    <line x1="10" x2="10" y1="95" y2="90" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="20" x2="20" y1="95" y2="90" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="30" x2="30" y1="95" y2="90" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="40" x2="40" y1="95" y2="90" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="50" x2="50" y1="95" y2="90" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="60" x2="60" y1="95" y2="90" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="70" x2="70" y1="95" y2="90" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="80" x2="80" y1="95" y2="90" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="90" x2="90" y1="95" y2="90" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="100" x2="100" y1="95" y2="90" stroke-width="0.5" fill="none" stroke="black"/>
    <text x="8" y="100" class="small">7</text>
    <text x="18" y="100" class="small">10</text>
    <text x="28" y="100" class="small">13</text>
    <text x="38" y="100" class="small">16</text>
    <text x="48" y="100" class="small">19</text>
    <text x="58" y="100" class="small">22</text>
    <text x="68" y="100" class="small">25</text>
    <text x="78" y="100" class="small">28</text>
    <text x="88" y="100" class="small">31</text>
    <text x="98" y="100" class="small">34</text>
    <line x1="105" x2="110" y1="10" y2="10" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="105" x2="110" y1="20" y2="20" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="105" x2="110" y1="30" y2="30" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="105" x2="110" y1="40" y2="40" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="105" x2="110" y1="50" y2="50" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="105" x2="110" y1="60" y2="60" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="105" x2="110" y1="70" y2="70" stroke-width="0.5" fill="none" stroke="black"/>
    <line x1="105" x2="110" y1="80" y2="80" stroke-width="0.5" fill="none" stroke="black"/>
    <text x="112" y="11" class="small">23</text>
    <text x="112" y="21" class="small">20</text>
    <text x="112" y="31" class="small">17</text>
    <text x="112" y="41" class="small">14</text>
    <text x="112" y="51" class="small">11</text>
    <text x="112" y="61" class="small">8</text>
    <text x="112" y="71" class="small">5</text>
    <text x="112" y="81" class="small">2</text>
    <rect x="10" y="10" width="90" height="70" stroke-width="0.4" fill="none" stroke="black"/>
    <rect x="20" y="20" width="70" height="50" stroke-width="0.2" fill="none" stroke="red"/>
    <rect x="20" y="20" width="70" height="50" stroke-width="20px" fill="none" stroke="blue" stroke-linejoin="round"
          stroke-opacity="0.2"/>
    <circle cx="20" cy="20" r="10" fill="red" stroke-width="0.2" fill-opacity="0.2" stroke-opacity="0.1"/>
    <circle cx="90" cy="20" r="10" fill="red" stroke-width="0.2" fill-opacity="0.2" stroke-opacity="0.1"/>
    <text x="11" y="13" class="small">C</text>
    <text x="97" y="13" class="small">D</text>
    <text x="21" y="23" class="small">A</text>
    <!--
                        	D = sqrt(10*10 + 10*10) = 14.14
                            d = 14.14 -10 = 4.14dx = dy = d / sqrt(2) = 2.93
                        	-->
    <polyline id="dog-bone-path1" points="20,20 17.07,17.07" fill="none" stroke="blue" stroke-width="0.3"
              stroke-opacity="0.5"/>
    <circle id="dog-bone-path1-material" cx="17.07" cy="17.07" r="10" fill="red" stroke-width="0.2" fill-opacity="0.2"
            stroke-opacity="0.1"/>
    <!--  other bone type -->
    <polyline id="dog-bone-path2" points="90,20 90,10" fill="none" stroke="blue" stroke-width="0.3"
              stroke-opacity="0.5"/>
    <circle id="dog-bone-path2-material" cx="90" cy="10" r="10" fill="red" stroke-width="0.2" fill-opacity="0.2"
            stroke-opacity="0.1"/>
  </g>
</svg>

<p>We see that the strategy "1" removes far less extra material than the strategy "2", so we will concentrate only on
the strategy "1". </p>

<p>At every G01 instruction, there is certainly a direction change, which can be tiny (consider milling an inner
circle, not as G02 or G03 but with a list of GO1 instructions) or big, here in our case a 90 degrees direction
change.</p>
<pre><code class="language-gcode">G1 X10.00 Y5.00
G1 X10.00 Y20.00  (go up to A)
G1 X31.00 Y20.00  (change of direction to the right)</code></pre>

<p>We shall insert a GCode block before changing the direction</p>
<pre><code class="language-gcode">G1 X10.00 Y5.00
G1 X10.00 Y20.00 (go up)
; fix up begin ------------------------
G1 X09.00 Y21.00 (goes 1mm top left)
G1 X10.00 Y20.00 (and back)
; fix up end --------------------------
G1 X15.00 Y20.00 (change of direction to the right)</code></pre>

<p>or, using incremental distance mode for the fix-up:</p>
<pre><code class="language-gcode">G1 X10.00 Y5.00
G1 X10.00 Y20.00 (go up)
; fix up begin ------------------------
G91           (incremental distance mode) 
X-1.00 Y1.00  (goes 1mm top left)
X1.00 Y-1.00  (and back)
G90           (absolute distance mode) 
; fix up end --------------------------
G1 X15.00 Y20.00 (change of direction to the right)</code></pre>

<p>In the following, I will prefer switching to incremental distance mode (G91) and back (G90) for the fixups.</p>

<p>In this first try, we "naively" gave at the left corner an extra travel of 1 mm in the NE direction. We can
certainly do better.</p>

<p><strong>Example-1</strong>: exact fixup, same geometry with a cutter of radius 3.0 mm</p>
We wish to calculate the cutter extra travel exactly in order to minimize the extra stock removal while achieving the
corner beeing milled completely as shown on the picture. 

<p>The right corner on the left is at coordinate [7.0, 23.0] and the cutter reaches the coordinate [10.0, 20.0]
position for it (see GCode). Thus there is a gap of </p>

<p><code>gap = sqrt(3.0*3.0 + 3.0*3.0) - 3.0 = 1.2426</code></p>

<p>between the corner C and the border of the cutter at point A.</p>

<p>So we know which extra travel <code>dx</code> and <code>dy</code> the cutter must travel in order to its border
reaches C: </p>
<pre><code>dx = gap * cos(3 *pi / 4) = -0.8786
dy = gap * sin(3 *pi / 4) = +0.8786</code></pre>

<p>The angle <code>3*pi/4</code> here is the direction of the outer corner (concave) angle bisection line, let's call
it the "orientation" of the corner. It is of course identical to the direction of AC, but in practice C is not known,
only the position of the cutter. not that the cutter "trajectory" makes exactly the same angle as the real geometry
when encountering a convex angle. So lets try to generalize for any corner "orientation". We denote this orientation
"bisect".</p>
<pre><code>dx = gap * cos(bisect) = -0.8786
dy = gap * sin(bisect) = +0.8786</code></pre>

<p>So the fixup is</p>
<pre><code class="language-gcode">; fix up begin ------------------------
G91 
G1 X-0.8786 Y0.8786 ( goes 0.8786 mm top left )
G1 X0.8786 Y-0.8786 ( back )
G90
; fix up end --------------------------</code></pre>

<p><strong>Example-2</strong>: exact fixup, same geometry but at the corner D on the right</p>

<p>The corner coordinate is [34.0, 23.0] and the cutter reaches the coordinate [31.0, 23.0] from the left. Remember,
the cutter radius is 3mm. The gap between the corner and the cutter border remains the same, as the angle is still a
right angle.</p>

<p>But the orientation of the corner is this time <code>pi/4</code>. </p>
<pre><code>dx = offset * cos(bisect) = 0.8786
dy = offset * sin(bisect) = 0.8786</code></pre>

<p>So the fixup for this corner is </p>
<pre><code class="language-gcode">; fix up begin ------------------------
G91
G1 X0.8786  Y0.8786   ( goes 0.8786 mm top right )
G1 X-0.8786 Y-0.8786  ( and back )
G90
; fix up end --------------------------</code></pre>

<p>Easy!</p>

<div class="info">
<p><strong>Info:</strong> For this particular case (cutter radius 3mm, angle 90 deg.), the gap is <code>1.2426 mm</code> 
and the fixups (angles orientations <code>pi/4</code> or <code>3pi/4</code>) <code>dx = 0.8786</code>, <code>dy = 0.8786 mm</code>.
For different cutter radiuses, the ratio gap / cutter radius (1.2426 / 3.0 = 0.41) shall remain the same.</p>
</div>

<h4>General case / automatic fixups</h4>

<p>Knowing only the GCode, the theoretical corner on the stock could be calculated in order to evaluate the gap between
the cutter border and the stock corner. Infact the stock corner does not have to be calculated at all, as the gap is
infact only function of the cutter diameter and the angle of the corner of the toolpath. The orientation of the corner
indeed does not play a role (for the gap size). </p>

<p><svg width="140mm" height="200mm" viewBox="0 0 140 200" version="1.1" id="svg5">
  <g id="angle_60" transform="translate(20 10)">
    <polyline points="0,30   60,0   120,30" fill="none" stroke="black" stroke-width="0.5"/>
    <polygon points="0,30   60,0   120,30  78,30  60,23   42,30" fill="blue" fill-opacity="0.2"/>
    <polyline points="20,30  60,11.5  100,30" fill="none" stroke="red" stroke-width="0.2"/>
    <circle cx="60" cy="11.5" r="10" fill="red" stroke-width="0.2" fill-opacity="0.2" stroke-opacity="0.1"/>
  </g>
  <g id="angle_45" transform="translate(30 50)">
    <polyline points=" 0,50  50,0  100,50" fill="none" stroke="black" stroke-width="0.5"/>
    <polygon points=" 0,50  50,0  100,50  72,50  50,28  28,50" fill="blue" fill-opacity="0.2"/>
    <polyline points="14,50  50,14  86,50" fill="none" stroke="red" stroke-width="0.2"/>
    <circle cx="50" cy="14" r="10px" fill="red" stroke-width="0.2" fill-opacity="0.2" stroke-opacity="0.1"/>
  </g>
  <g id="angle_30" transform="translate(40 100)">
    <polyline points=" -6,80  40,0   86,80" fill="none" stroke="black" stroke-width="0.5"/>
    <polygon points=" -6,80  40,0   86,80  62,80  40,40  18,80" fill="blue" fill-opacity="0.2"/>
    <polyline points="  6,80  40,20  74,80" fill="none" stroke="red" stroke-width="0.2"/>
    <circle cx="40" cy="20" r="10" fill="red" stroke-width="0.2" fill-opacity="0.2" stroke-opacity="0.1"/>
  </g>
</svg>
 </p>

<p>The gap (distance between corner and cutter border) is </p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mi>gap</mi>
  <mo>=</mo>
  <mfrac>
    <mrow>
      <msub>
        <mi>cutter</mi>
        <mn>R</mn>
      </msub>
    </mrow>
    <mrow>
      <mi>sin(a)</mi>
    </mrow>
  </mfrac>
  <mo></mo>
  <msub>
    <mi>cutter</mi>
    <mn>R</mn>
  </msub>
  <mo>=</mo>
  <mfrac>
    <mrow>
      <mi>1</mi>
      <mo></mo>
      <mi>sin(a)</mi>
    </mrow>
    <mrow>
      <mi>sin(a)</mi>
    </mrow>
  </mfrac>
  <msub>
    <mi>cutter</mi>
    <mn>R</mn>
  </msub>
</math>
<p>where \(a\) is the <strong>half the size of the corner's angle</strong>. So for a cutter radius of 1:</p>
<ul>
  <li>\(a = 60^{\circ} \implies gap = 0.15 \)</li>
  <li>\(a = 45^{\circ} \implies gap = 0.41 \)</li>
  <li>\(a = 30^{\circ} \implies gap = 1.00 \)</li>
</ul>

<p>Considering the GCode pattern (constitued of 3 G1 lines) </p>
<pre><code class="language-gcode">G1 X&lt;x1&gt;  Y&lt;y1&gt;
G1 X&lt;xm&gt;  Y&lt;ym&gt;
G1 X&lt;x2&gt;  Y&lt;y2&gt;</code></pre>

<p>we wish to generate a fixup for this GCode pattern, this means at the points \([x_m:y_m]\). As it turns out, we do
not need to know if we are milling for an "Inside" or "Outside" operation, we do not need to check either if the angle
is concave or convex! Consider the following example: a spade. We would like to mill "Inside" or "Outside"</p>

<p>For an "<strong>Inside</strong>" operation, around the sharp corner "A", the angle in is concave and the size of the
angle "inside" is larger than 180. The Gcode path of the "Inside" operation will be smooth around A, a fixup is thus
not needed; the GCode near A will be a succession of small G1 increments without sharp transitions. At corner "B", the
angle is convex and the size of the angle "inside" is smaller than 180 . A fixup will be needed as the GCode path
will also present a sharp corner of the same magnitide as the stock corner itself. </p>

<p>For an "<strong>Outside</strong>" operation, at corner A, the angle is convex and the size of the angle "outside" is
smaller than 180 and thus the GCode at "A" will need to have a fix-up, while the GCode at corner "B" (where the size
of the angle "outside" is larger than 180) will be smooth, consisting again of a succession of small G1 increments
without sharp angles.</p>

<p>At the locations where the GCode path is not smooth the fixups have to be performed. We set as
<strong>threshold</strong> an angle of <strong>120 degrees</strong>, slightly larger than a right angle. Above this
threshold (from 120 to 180), no fixup is needed at all as the gap if about only one tenth of the cutter radius or
less, or it is simply an "exterior travel". Between 0 and 120, we have to calculate the right direction of the
angle bissection, the "orientation" of the corner. The "orientation" must be "outside the corner" in order to mill
"inside" the corner.</p>

<p><svg width="1000" height="500" viewBox="0 0 1000 500" version="1.1" id="svg_spade">
  <path
        d="m213.23 502.9c-195.31 199.54-5.3525 344.87 149.07 249.6.84137 49.146-37.692 95.028-61.394 138.9h166.73c-24.41-42.64-65.17-89.61-66.66-138.9 157.66 90.57 325.33-67.37 150.39-249.6-91.22-100.08-148.24-177.95-169.73-204.42-19.602 25.809-71.82 101.7-168.41 204.42z"
        stroke="#000000" transform="translate(0 -200) scale(0.7)"/>
  <text x="235" y="350">A</text>
  <text x="330" y="420">B</text>
</svg>
 </p>

<p></p>

<p>Let's do some maths! the slope of the GCode incoming segment is \( m_1 = (y_m - y_1) \ (x_m - x_1) \) and the slope
of the GCode outcoming segment is \( m_2 = (y_2 - y_m) \ (x_2 - x_m) \) </p>

<p>incoming segment equation: \( y = m_1 x + k_1 \) or, in another form \( a_1 x + b_1 y + c_1 = 0\) </p>

<p>outcoming segment equation: \( y = m_2 x + k_2 \) or, in another form \( a_2 x + b_2 y + c_2 = 0\) </p>

<p>The angle at the toolpath mid point is calculated with</p>

<p>\(cos(\beta) = \displaystyle \frac{ u \cdot v}{ \| u \| \cdot \|v\| } \) </p>

<p>and the internal and external bisections line equations of the corner are given by the two equations</p>

<p>\( \displaystyle \frac{ a_1x + b_1y + c_1}{ \sqrt{a_1^2 + b_1^2} } = +/- \frac{ a_2x + b_2y + c_2}{ \sqrt{a_2^2 +
b_2^2} } \implies A_i x + B_i y + C_i = 0 \)</p>

<p>so the angles of these two bisections lines is given with \( tan(\alpha_i) = - A_i / B_i\) with \( \alpha_i \) in
\([-\pi/2:\pi/2]\)</p>

<p>The correct bisection is the one such that its slope is contained in the slopes of the two corner's segments, and
the orientation must look "outside" the corner.</p>

<p></p>

<p>Let's try our formulas for a sharp angle. Let's say the cutter radius is 1mm. The GCode encountered is</p>
<svg width="70" height="55" viewBox="0 0 70 55" version="1.1">
  <polyline points="10,30  60,0  30,50" stroke-width="0.75" fill="none" stroke="black"/>
</svg>
<pre><code class="language-gcode">G1 X-2  Y2
G1 X4   Y4
G1 X2   Y-2</code></pre>

<p>So obviously there is a sharp corner at \([4, 4] \). The corner angle is \( \beta = 53.13\).</p>

<p>The slopes of the incoming and outcoming segments are : \(m_1 = 1/3 \) and \( m_2 = 3 \) and the two bisections
slopes are \( -1\) and \(1;\) so the correct bisection is the second one, and its correct orientation is +45</p>

<h5>Gap</h5>

<p>\( gap = 0.414 \)</p>

<h5>Extra Travel</h5>

<p>\( dx = 0.874 \)</p>

<p>\( dy = 0.874 \)</p>

<h4>Example 2</h4>
<svg width="50" height="45" viewBox="0 0 50 45" version="1.1">
  <polyline points="10,40  10,2  50,2" stroke-width="0.75" fill="none" stroke="black"/>
</svg>
<pre><code class="language-gcode">G1 X0.0  Y0.0
G1 X0.0  Y4.0
G1 X4.0  Y4.0</code></pre>

<p>So obviously there is a sharp (right) corner at \([0, 4] \). The corner angle is \( \beta = 90\).</p>

<p>The slopes of the incoming and outcoming segments are \(m_1 = -\inf \) and \( m_2 = 0 \) and the slopes of the
bisections are \( -1\) and \(1\). The correct bisection is the first one (slope -1), and its correct orientation is
+135 (not -45) pointing "outside" the corner.</p>

<h5>Gap</h5>

<p>\( gap = 0.414 \)</p>

<h5>Extra Travel</h5>

<p>\( dx = -0.88 \)</p>

<p>\( dy = 0.88 \)</p>

<p><strong>PyCut GCode Dressup GUI</strong></p>

<p>How to integrate this handling into <strong>PyCut</strong> ? There is a setting option "<strong>GCode DogBones
threshold</strong>" which is per default 120. A completely separate utility "gcode_dressup.py" will be called upon
GCode generation completion to transform the GCode for the operations requiring it.</p>

<p>In the operations table, we add a column "fixups" as a checkbox, which, for every operation, can be set on or off.
Moreover, in the GCode Viewer/GCode simulator GCode browsers, lines corresponding to added fixups (comprised between
the comment lines </p>
<pre><code class="language-gcode">; start fixup</code></pre>

<p>and </p>
<pre><code class="language-gcode">; end fixup</code></pre>

<p>will have a blue background in order to clearly identify them.</p>

<h3 id="APPENDIX-01">Appendix-1: SVG Editors</h3>

<p>It seems there are plenty of free SVG editors around there. Well, let me share my opinion about a few of them... </p>

<p>I will simply try <strong>to edit and save a closed path</strong> composed of lines, arcs and bezier curves similar
to what I've edited per hand: about 20 segments representing my workpiece, with mixed straight lines, arcs and bezier
curves.</p>

<p><strong>I know that every app has its own learning curve</strong>, but I try use the apps without investing to much
time. This means, I act as a very basic user. If I do not succeed, this is due in part to my inexperience, but also in
part to the difficulty of use of the app.</p>

<p>Finally, <strong>after having tried quite a lot of them</strong>, I give here only the ones worth a mention.</p>

<h3>Free software</h3>

<h4>Inkscape</h4>

<p><strong>Editing paths is far too complicated</strong> (to me) and completely impracticable for paths looking like
CAD work. </p>

<p>To go further in details, editing points coordinates "per hand" is nearly impossible as the coordinates are only
accessible from the "d" string, which is not really human readable. Here is an example of a polyline with 8 points:</p>
<pre><code>M 5.9999998,35.999999 10,33 l 5,2.999999 -1,-4 h 7 V 41 H 12 L 8.9999999,38.999998</code></pre>

<p>BTW, note how absolute and relative keywords are given in the path. Question: what are the coordinates of the fifth
point?</p>

<p>What about the other shapes? I "hate" the fact that the circles are given from their "bounding box", not from the
center with radius (ok it is possible, but always have to figure out how). To obtain a "clean" SVG file (free from
sodipodi namespace stuff), do not forget to export your project as "SVG". </p>

<p>But back to paths. Concatening segments to form a single path doesn't even work as expected. The simple task
consisting of concatenating a polyline and a bezier curve -in this order- (which are joined) seems not to work! There
is the "<strong>combine</strong>" command, but the result is a single path (ok... ) containing 2 subpaths (with "M"),
which is not Ok, the first one beeing the bezier curve and the second one beeing the polyline, this means in reversed
order. Sure, with "M"s everywhere, the segments ordering is not that important, is it! </p>

<p><strong>A very desapointing implementation from Inkscape I would say</strong>. Conclusion: <strong>unusable if you
want to generate complex paths.</strong></p>

<p>PS: There is the "Draw Bezier and straight line tool" with mode "Create regular Bezier path" but after many many
hours of trial (despite YouTube tutorials) I did not succeed to use it properly. Is it just me ? With it you cannot
anyway mix your path with an arc curve.</p>

<p>PPS: Infact I believe that Inkscape is not suitable for path editing. Like most of SVG applications, it is meant for
painting.</p>

<h4>LibreCAD <span style="color:#008000">****NEARLY GOOD****</span></h4>

<p>It is (was) a fork of QCAD (2011). It looks a lot like QCAD, but the (my) first feeling is that the user interface
seems better. <strong>The SVG export is exactly what one would expect (well, nearly)</strong>. There is minimal extra
LibreCAD namespace stuff in the output. Do not know yet how to assign ids to the entities (not good). You only have to
take care that in the SVG format y = 0 is the top of the drawing, so coordinates in the SVG file are inverted from
coordinates in the app (which is normal). The y = 0 correspond to the highest coordinate of your items in the canvas
(Note: in <strong>QCAD</strong> the coordinates are the same and there is a global svg transform="scale(1,-1)". The
viewBox is calculated accordingly. It would be nice to have this option in <strong>LibreCAD</strong>).</p>

<p><strong>Splines</strong> <strong>through</strong> <strong>3 points correspond to bezier quadratic curves</strong>,
while <strong>splines through 4 or more points are not cubic bezier curves but only sequence of quadratic
curves</strong> (it seems possible! is it ? they really look to be smooth of order 3!).</p>

<p><strong>There is another splines button (strange!) where it is possible to indicate which degree (1, 2 or 3) the
spline has to be. And for 2 and 3 these are bezier quadratic or cubic curves with control points entered from the
UI.</strong> Setting for the degree is in the main menu bar (this is LibreCAD concept, but not so straight to be seen
if one not knows).</p>

<p>Editing polylines/arcs/quad bezier and concatenate them together ("<strong>create polyline from existing
segments</strong>") works "half", (<strong>SVG output is a single &lt;path&gt; entity</strong>) but here there is a bug
or let's say a missing feature: one cannot concatenate polylines/arcs with beziers/splines. </p>

<p>Snap stuff is perfect, with many clear and practical snap options (correction: nearly perfect: cannot snap on bezier
curves)</p>

<p><strong>So this is a real pity that LibreCAD does not perform the concatenation of lines/arcs with beziers/splines
into a single SVG path, it is fixable per hand in the output, but why the hell is LibreCAD not able to perform
concatenation of lines/arcs with splines?</strong></p>

<p>Conclusion: <strong><span style="color:#008000">A good SVG "path" generator/exporter that is unfortunately not
completely finished.</span></strong></p>

<h4>FreeCAD <span style="color:#008000">****VERY GOOD****</span></h4>

<p>As of version 1.0 (2025), the sketcher has dramatically improved compared to previous versions and has an SVG export which 
works quite nicely. I found nevertheless the following caveats: </p>
<ul>
  <li>The viewbox is calculated on the base of the items in the sketcher, and thus typically will not be from 0,0.
    Width and height are also calculated from theses items</li>
  <li>The svg root layer has a transformation with a translate (to view all items nicely in a browser) and a scale (1,-1)
    so that the Y coordinates of all items are "inversed" (and thus follow the natural direction, the opposite of the
    SVG standard. <strong>This means that the output will have to pass through the "svgresolver" utility to remove all
    transformations in order to be used by PyCut</strong>.</li>
  <li>Circles are exported as <code>circle</code> (Ok). Lines, Rectangles, Polygons and Ellipses are exported as
    <code>path</code> (not Ok). The exporter should recognize when a "shape" is formed only with straight lines,
	so that it is exported as polygon, polyline, line or even rectangle when it is the case.</li>
  <li>Quadratic bezier  and cubic bezier are supported</li>
  <li>No <strong>Z</strong> at the end of a closed path</li>
</ul>

<p>But it is good enough to become my potential default SVG editor.</p>

<p>Conclusion: <strong style="color:#008000">A very promising SVG generator/exporter </strong>that could be better if
Line were to be exported as <code>line</code>, Polyline as <code>polyline</code>, Rectangles as <code>rect</code>, 
Polygons as <code>polygon</code>. I also would rather like an output without transformation.</p>


<h4>SolveSpace <span style="color:#ff00ff">****BEST****</span></h4>

<p>Ever heard of it? A parametric system as known from the 3D modellers. <strong>Incredible!</strong> The GUI looks
like from the beginning of the '80s, but <strong>usability/features more than top</strong>.</p>

<p><strong>SVG export perfect (well, nearly perfect)</strong>. I found nevertheless the following caveats:</p>

<ul>
<li>The paths have no id, but ids are mandatory for <strong>PyCut</strong>.</li>
<li>Always be sure to hide the constraints so that they are not exported in the svg.</li>
<li>There are only cubic bezier curves, quadratic bezier curves are missing.</li>
<li>The SVG closed path "Z" is also missing.</li>
</ul>
</p>

<div class="info">
<p><strong>Note</strong>: To achieve a quadratic bezier from a cubic one, the vector C1-C2 from the 2 control points must only be
a third of the vector AB the start and end points! This constraint on the control points could be added in SolveSpace! Or a real
quadratic entity could be built in. Note that making the two control points coincident is not a solution, this does not lead to 
a quadratic bezier although it looks similar</p>
</div>

<p>Conclusion: <strong style="color:#008000">The best SVG "path" generator/exporter </strong>I have found so far. </p>

<div class="info">
<p><strong>Note</strong>: in 2023, a <strong>Blender</strong> add-on called <strong>CAD Sketcher</strong> is in
development, which utilize the SolveSpace library for sketching. Maybe the user interface will be there even better
(and offers the SVG export functionality).</p>
</div>

<h4>Fusion 360</h4>

<p>The free version is also incredible. The parametric "sketcher" is beautiful. There is no SVG export per default, but
it seems there is an add-on that costs about 15$, but I did not buy/try it because I gave up in the meanwhile looking
for SVG editor... This add-on is certainly awesome.</p>

<h4>XFig</h4>

<p>My beloved drawing editor during my youth! Completely outdated, but still the best! Unfortunately the SVG export is
deficient. There are Bezier curves (really?) i.e. splines with control points (it looks like Bezier) but the SVG export
outputs them as polylines (with many points). <strong>Conclusion: unusable</strong></p>

<p></p>

<h3><strong>Online editors:</strong></h3>

<p>There are plenty of them, but they all seem to be meant for painting (like Inkscape), not for CAD. Finally found
this one:</p>

<h4>SvgPathEditor <span style="color:#ff00ff"><span style="color:#ff00ff"></span></span><span
style="color:#ff00ff">****EXCELLENT****</span></h4>

<p>It is solely focused on editing svg paths. You can try it at <a
href="https://yqnn.github.io/svg-path-editor/">https://yqnn.github.io/svg-path-editor/</a>.</p>

<p>Of course it cannot compare to <strong>FreeCAD</strong> or <strong>SolveSpace</strong>, but its concept is excellent, 
which makes it so easy to generate a path, segment after segment. The result can then be copy/pasted into your SVGs,
editted per hand.</p>

<h4>Others:</h4>

<p>I do not mention them because the list would be too long... but I did not find something I was pleased of.</p>

<p></p>

<h3>Non-free software</h3>

<h4>DesignCAD</h4>

<p>The free version has the same capabilities as the full version, excepted the exports to other formats. Bad!</p>

<h4>Solid Edge 2D Drafting (Siemens)</h4>

<p>The 3.8 GB big app from Siemens is <strong>free of charge</strong>. It is incredible software. But It seems there is
no SVG export at all. "Schade".</p>

<h4>Draftsight 2D (Dassault)</h4>

<p>Only a 30 days trial version. It has a "Power Tool" named "2D G-Code generator"! Should I forget
PyCutl? (No). SVG export seems to be more meant as a picture for display only purpose.</p>

<h4>What else?</h4>

<p>...</p>

<h3>Conclusion</h3>

<p>The fact that it is so difficult to find an acceptable SVG path "writer" program let me wonder why it is the case.
And why does only <strong>FreeCAD</strong> and <strong>SolveSpace</strong> perform the task correctly?</p>

<p>The primary usage of SVG is displaying images, not being a format for CAM input. So why bother exporting it clean.
The svg standard is huge, the svg path definition is quite complicated, parsing it is a difficult task, and thus in 
return exporting a custom data format as svg data in a right and clean manner is also not straightforward (when the
data format is not well suited for such an export). 
But who else would want to import svg files as a kind of CAM format? Response: the applications that do not want to use 
an other (maybe more complicated) format, because yes, SVG can be indeed simple when utilizing only its basic features.</p>

<p>The SVG format, sure, can be viewed in a browser, can be edited with a text editor, and in some points is very practical 
(that's why <strong>PyCut</strong> use it). By the way, unfortunately the SVG format completely ignores the concept of 
multiline/multipolygon etc. Polygons have no "interiors" so they must be defined as such in a path composed of 2 or more 
subpaths for this purpose. Not very practicable.</p>

<p><strong>All in all very desapointing, excepted <span style="color:#008000">FreeCAD</span>, <span
style="color:#008000">SolveSpace</span> and <span style="color:#008000">SvgPathEditor</span>!</strong></p>

<h4><strong><span style="color:#0000ff">Per hand</span></strong></h4>

<p>Finally my prefered method! Per hand you can also write items in the <code>&lt;defs&gt;</code> section, and use
these items repeatidly with transformations with the <code>&lt;use&gt;</code> tag. My utility
<strong>svgresolver.py</strong> then transforms this svg file into another one, usable for <strong>PyCut. Not the
perfect toolchain I admit, but well my svgs are not that complicated</strong>. One has to understand how to write an
arc/bezier curve per hand, it is not that difficult and can always use the <strong>SvgPathEditor</strong> tool. And
your hand written svgs are then "<strong>clean</strong>" and easily modificable. </p>

<p></p>

<h3 id="APPENDIX-02">Appendix-2: SVG Units and Scale Factor</h3>

<div class="info">
<p><strong>Info</strong>: When creating a svg "per hand" (with a text editor), the user does not even have to care
about this units scale factor.</p>
</div>

<p>What is this? Let's take an example: in <strong>Inkscape</strong>, the user would set the document's size to
<strong>100x40 mm</strong>, supposedly the size of the material to work on. Inkscape automatically sets the
<strong>user units scale </strong><strong>to 1</strong>. Note that the user units are not "px" or whatever. This means,
<strong>1 "user unit" is equal to 1 mm (and the viewbox is "0 0 100 40" while width="100mm" and
height="40mm")</strong></p>

<div>
<img src="doc/Inkscape_settings_mm.png" width="563"> </div>

<p>Of course when editing the svg (in Inkscape or in a text editor), <strong>the user is only concerned with the user
units</strong> : he draws a rectangle of size 20x30 at the location 10x10. The users may simply even not be aware of
this fact. When choosing mm, conversion from <strong>user units</strong> to <strong>mm</strong> is absolutely
straightforward as, as said, the user units scale is 1 per default .</p>

<p>Let's consider now the case where the user switches to <strong>inches</strong> for the document size. The size of
the document becomes then <strong>3,93701x1,57480 inches</strong> (yes, 100 / 25.4 is 3.93701). Note that
<strong>Inkscape</strong> automatically change the <strong>user units scale to 25.4</strong>. Because of this, the
<strong>view box remains at "0 0 100 40"</strong>. That way, a rectangle filling the full document size is still
100x40.</p>

<div>
<img src="doc/Inkscape_settings_in.png" width="563"> </div>

<p>Filling a box half the size of the document is 50x20, right, but what are real physical dimensions of that box ? The
user would have to steadily calculate from fancy user units (ex: 50x20) in inches</p>

<p>But why would a user use inches and work with user units scale factor 25.4 (leading infact to work in mm) ? The user
can set the user units scale factor to 1. The effect of this is that now, in order to fill the whole document with a
rectangle, the rectangle has to be of the size user unit size of 3.93701x1.57480. </p>

<p>Of course the size of the material is certainly not 3.93701x1.57480 inches, but something like 5x3 inches: an human
readable size. The user knows that he has to draw a rectangle inside the material of size let say 1.5x1.2 inches. And
these dimensions are the ones that are effectively saved in the svg document. So the user units are exactly the same as
the "physical units" when choosing a scale of 1.</p>

<p>Now how can <strong>PyCut</strong> handles these settings? <strong>PyCut</strong> only works with the <strong>user
units</strong>. <strong>PyCut</strong> will calculate toolpaths in the same order of magnitude of the user units values
of the svg. If you choose "<strong>mm</strong>" for the gcode output, you would have set your svg document size in
"<strong>mm</strong>", and the <strong>user unit scale to 1</strong>. Because of this, the gcode X,Y and Z values are
the same as the one of the paths values.</p>

<p>If you choose "<strong>in</strong>" for the gcode output, then certainly you have set your svg document size in
"<strong>in</strong>", and the <strong>with user unit scale equals to 1</strong>,no conversion is either needed. </p>

<p>Note that this scale factor is not explicitely given in the svg file. It is calculated from the ratio viewbox /
width. It is eventually the task of the user to know what is the user units scale value, and, theorically, to set it in
<strong>PyCut</strong>. But my opinion is, working with a user unit scal of 1 is preferably. </p>

<p><strong><span style="color:#0000ff">I personnaly stick to svg document units in "mm" with user units scale factor of
1, and output my gcode in mm. No confusion! </span></strong></p>

<div class="warning">
<p><strong>Warning</strong>: The user could use "mm", and set a scale factor of 10 or whatever, but it certainly makes
no sense.</p>
</div>

<p>The further <strong>PyCut Gcode Units</strong> setting is not only a flag to set the code <strong>G20</strong>
(inches) or <strong>G21</strong> (mm) inside the gcode file: it also allows the proper conversion of the tool diameter
physical size (inch or mm) in user units.</p>

<p>The rule is:</p>
<ul>
  <li><strong>Gcode Units</strong> in "mm": tool diameter is transformed to mm - the same as the user units</li>
  <li><strong>Gcode Units</strong> in "in": tool diameter is transformed to inch - the same as the user units</li>
</ul>

<div class="warning">
<p><strong>Warning</strong>: <strong>PyCut</strong> assumes that for "<strong>mm</strong>" or "<strong>in</strong>",
the <strong>user unit scale factor is always 1</strong> .</p>
</div>

<p></p>

<h3 id="APPENDIX-03">Appendix-3: GCODE Viewers</h3>

<p>Of course, CANDLE offers a GCODE viewer. There nevertheless a few ones (to my knowledge) worth a mention:</p>
<ul>
  <li>NCnetic <span style="color:#ff00ff"><strong>****EXCELLENT****</strong></span></li>
  <li>PlanetCNC (which is a GCode sender -with dedicated hardware- as well)</li>
  <li>what else ?</li>
</ul>

<p>Just search in the Internet for them.</p>

<p>Real GCODE simulators (with material removal) are on the other way seldom.</p>
<ul>
  <li>Camotics: unfortunately very resources intensive and not so accurate in the details</li>
  <li>CNCSimulator PRO (not free)</li>
  <li>FreeCAD ? how to import gcode into it ?</li>
  <li>Blender ? see BlenderCAM add-on - not sure if there is a simulation</li>
  <li>what else ?</li>
</ul>

</div>
</body>
</html>
